<!DOCTYPE html>
<html lang="en">

<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BR6YH9S6MS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-BR6YH9S6MS');
  </script>

  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-54DDMRW8');</script>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebSite",
    "name": "The Noble Quran with English Translation",
    "url": "https://muslim1446.github.io/",
    "logo": "https://raw.githubusercontent.com/muslim1446/Quran-english-bahasa.github.io/master/bismillah.ico",
    "description": "Listen to and read the Noble Quran with the English translation by Saheeh International, featuring audio from VerseByVerseQuran.com."
  }
  </script>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="canonical" href="https://muslim1446.github.io/">
  <meta name="description" content="Listen to and read the Noble Quran with the English translation by Saheeh International. Provides audio and text for all chapters.">
  <meta name="keywords" content="Quran, Qur'an, The Noble Quran, The Noble Qur'an, Saheeh International, audio Quran, English translation, online Quran, Quran recitation, listen to Quran">
  <meta name="author" content="github/Muslim1446">

  <meta property="og:title" content="The Quran with English Translation and Audio">
  <meta property="og:description" content="Listen to and read the Noble Quran with the English translation by Saheeh International. A complete online resource for all chapters.">
  <meta property="og:image" content="https://muslim1446.github.io/Q00.png">
  <meta property="og:url" content="https://muslim1446.github.io/">
  <meta property="og:type" content="website">

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/muslim1446/muslim1446.github.io/refs/heads/master/index.ico">

  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>

  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Cairo:wght@800&display=swap" as="style">
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@800&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic&display=swap" rel="stylesheet">

  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.1/gsap.min.js" defer></script>
  <script src="/js/index/hash.js" defer></script>
  <script src="/js/index/list.js" defer></script>
  <script src="/js/main.js" defer></script>
  <title>The Quran with English Translation and Audio</title>

  </head>

<body>
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-54DDMRW8"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>
    // TV UPDATE: Enhanced handleKeyPress, but we'll also add direct click listeners and tabindex
    function handleKeyPress(event) {
        if (event.key === 'Enter' || event.keyCode === 13) {
            const focusedElement = document.activeElement;
            if (focusedElement && (focusedElement.tagName === "BUTTON" || focusedElement.tagName === "A" || focusedElement.hasAttribute('role') && focusedElement.getAttribute('role') === 'button')) {
                focusedElement.click();
            }
        }
    }
    document.addEventListener("keydown", handleKeyPress);
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
        const audio = document.getElementById('audio');
        if ('mediaSession' in navigator) {
            function updateMediaSession() {
                const chapterName = document.title; // Assumes a dynamic title change
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: chapterName || 'The Quran',
                    artist: 'Mishary Alafasy',
                    album: 'The Noble Quran Audio',
                    artwork: [
                        { "src": "https://muslim1446.github.io/Q00.png", "sizes": "512x512", "type": "image/png" }
                    ]
                });
            }
            updateMediaSession();
            // No need for a frequent interval, just update on track change
            // navigator.mediaSession.setActionHandler...
        }
        const firstFocusable = document.querySelector('button, a, [tabindex="0"]');
        if (firstFocusable) {
            firstFocusable.focus();
        }
    });
  </script>

  <style>
    #audio {
      display: none; /* Hide the native audio player */
    }
    @font-face {
      font-family: 'Verdana';
      font-weight: 400;
      src: local('Verdana'), url('https://muslim1446.github.io/a/verdana.ttf') format('truetype'); /* TV UPDATE: Corrected format to truetype */
    }


    /* TV UPDATE: General body styles for TV readability */
    body { 
      font-family: Verdana, Geneva, Arial, sans-serif; 
      background-image: url('https://raw.githubusercontent.com/muslim1446/muslim1446.github.io/refs/heads/master/a/BGw.png');
      background-size: cover;
      background-repeat: no-repeat;
      color: black; 
      transition: background-color 0.3s, color 0.3s; /* TV UPDATE: Shortened transition for responsiveness */
      margin: 0;
      padding: 20px; /* TV UPDATE: Ensure some padding around content */
      font-size: 18px; /* TV UPDATE: Base font size, will be increased for TV */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE10+/Edge */
      user-select: none; /* Standard */
      overflow-x: hidden; /* TV UPDATE: Prevent horizontal scrollbars if content is slightly too wide */
    }
      background-size: cover;
      background-repeat: no-repeat;
      color: black; 
      transition: background-color 0.3s, color 0.3s; /* TV UPDATE: Shortened transition for responsiveness */
      margin: 0;
      padding: 20px; /* TV UPDATE: Ensure some padding around content */
      font-size: 18px; /* TV UPDATE: Base font size, will be increased for TV */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE10+/Edge */
      user-select: none; /* Standard */
      overflow-x: hidden; /* TV UPDATE: Prevent horizontal scrollbars if content is slightly too wide */
    }

    /* TV UPDATE: Focus styles for D-Pad navigation */
    *:focus {
        outline: 3px solid orange !important; /* !important to override other outlines if necessary */
        box-shadow: 0 0 10px rgba(255, 165, 0, 0.7) !important;
        /* transform: scale(1.03); /* Optional: slight scale */
        transition: outline 0.1s ease-in-out, box-shadow 0.1s ease-in-out; /* transform 0.1s ease-in-out; */
    }
    /* TV UPDATE: Specific focus for interactive elements if more distinction is needed */
    button:focus, select:focus {
        /* background-color: #eee; /* Example: slight background change */
    }


    /* TV UPDATE: Styles for TV screens - larger fonts, more spacing */
    @media (min-width: 1280px), (hover: none) and (pointer: coarse) { /* Targeting larger screens or typical TV input */
        body {
            font-size: 24px; /* Larger base font size for TV */
            padding: 40px;
        }
        h1 { /* Assuming you might add an h1 later */
            font-size: 2em; /* e.g., 48px */
            margin-bottom: 20px;
        }
        label {
            font-size: 1.2em; /* Relative to body font */
            margin-bottom: 8px;
        }
        .chapterSelect, .verseSelect {
            padding: 18px; /* Larger padding for TV */
            font-size: 0.8em; /* Relative to body font */
            margin-bottom: 15px; /* More space between selects */
        }
        #darkModeToggle, #hideS, #hideA, #play-pause {
            padding: 15px 25px; /* Larger padding */
            font-size: 1.1em; /* Larger font */
            border-radius: 8px; /* Slightly larger radius */
        }
        #report, .translation {
            font-size: 1.3em; /* Larger text for readability */
            max-width: 90%; /* Ensure it's not too wide */
            margin-left: auto;
            margin-right: auto;
        }
    .dark-mode {
  background-image: url('https://raw.githubusercontent.com/muslim1446/muslim1446.github.io/refs/heads/master/a/BGw.png');
  background-size: cover;
  background-repeat: no-repeat;
  color: black;
}
        #verseImageContainer img {
             max-width: 80%; /* Ensure it's not too wide on TV, adjust as needed */
             margin-top: 20px;
        }
    }

    .chapterSelect, .verseSelect { 
      font-family: 'Noto Sans Arabic', sans-serif; 
      padding: 12px; 
      background-color: #f0f0f0; 
      border: 1px solid #ccc; 
      font-size: 16px; 
      border-radius: 8px;
      width: 100%; /* TV UPDATE: Consider max-width for very wide screens if needed, but 100% of parent is okay */
      direction: rtl; 
      margin-bottom: 10px; /* TV UPDATE: Added some space below selects */
    } 
    .parentContainer { 
      display: flex; 
      flex-direction: column; 
      align-items: center; /* TV UPDATE: Center the selects for a more TV-friendly layout */
      width: 80%; /* TV UPDATE: Wider for TV, but not full width */
      max-width: 600px; /* TV UPDATE: Max width to prevent them from becoming too wide */
      margin: 20px auto; /* TV UPDATE: More margin and auto for centering */
    } 
    label { font-size: 18px; margin-bottom: 5px; display: block; text-align: center; /* TV UPDATE: Center labels */ } 
    
    .dark-mode {
        background-size: cover;
        background-repeat: no-repeat;
        color: white;
    }
    
    #verseImageContainer { 
      min-height: 200px; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      margin-top: 20px; /* TV UPDATE: Add some top margin */
    } 
    #verseImageContainer img { 
      max-width: 90%; /* Default for PC/Laptops, TV media query will adjust */
      height: auto; /* TV UPDATE: Ensure height is auto */
      margin-top: 10px; 
      /* margin-left: 10%; margin-right: 10%; TV UPDATE: Centering handled by parent flex */
      display: block; 
      transform: scale(0.95); 
      transition: opacity 1s ease-in-out, transform 1s ease-in-out, filter 2s ease-in-out; 
    } 
    .dark-mode #verseImageContainer img { 
      filter: invert(1); 
      transition: opacity 1s ease-in-out, filter 2s ease-in-out, transform 1s ease-in-out; 
    } 
    /* TV UPDATE: Simplified media queries for image, made more general */
    @media screen and (max-width: 768px) { /* Smaller screens / Portrait */
      #verseImageContainer img { max-width: 100%; }
      .parentContainer { width: 95%; }
    }
    

    .dark-mode #darkModeToggle { background-color: #333; color: white; } 
    #darkModeToggle i { font-size: 10px; } 

    #report1 {
   display: none;
    /* Positioning for the bottom-left corner */
    position: fixed; /* Stays in place relative to the viewport */
    bottom: 3%;
    left: 0;
    z-index: 4; /* Ensures it's on top of other content normally */

    /* Initial size and trapezium shape */
    width: 260px; /* Adjust as needed */
    height: 29px;  /* Adjust as needed */
    background-color: #ffffff; /* Base green color */
    clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%); /* Defines the trapezium shape */
    /* For a more precise trapezium, you might need to adjust the last point's X-coordinate */

    /* Border for the trapezium */
    border-bottom: 2.4px solid #fffffff; /* Different green border color */
    border-left: 2.4px solid #4CAF50;
    /* Only bottom and left for a clean look, adjust as needed */

    /* Text styling */
    color: white; /* Text color */
    font-family: "Cairo", sans-serif;
    font-optical-sizing: auto;
    font-weight: 800;
    font-style: normal;
    font-variation-settings:
    "slnt" 0;
    font-size: 0.9em; /* Adjust text size */
    display: flex; /* Use flexbox for text positioning */
    justify-content: center; /* Centers the content initially */
    margin-right: -2%; 
    align-items: flex-start; /* Aligns content to the top */
    padding: 1px; /* Padding for the text inside the trapezium */
    box-sizing: border-box; /* Include padding in width/height */

    /* Make it focusable (important for D-Pad) */
    tabindex: 0; /* Allows the div to receive focus */
    outline: none; /* Remove default focus outline if desired, but be careful with accessibility */

    /* Smooth transition for hiding/showing */
    transition: all 0.3s ease-in-out; /* Smooth transition for property changes */

    /* Ensure initial text positioning (adjust margin-right if needed) */
    /* The `margin-right: -2%;` from your sample pushes the content right.
       If you want the text "Booking number: 1" to appear on the "top of background area and very right of the background area" as per your original prompt,
       you might adjust `justify-content` and `align-items` more.
       For "very right and top":
       justify-content: flex-end;
       align-items: flex-start;
       But your current `justify-content: center;` combined with `margin-right: -2%;` might be your desired visual.
       I'll keep your provided `justify-content: center;` for now.
    */
}

/* Style for the text inside the report div */
#report1::before {
    display: none;
    /* If you want this specifically to the very right and top of the trapezium: */
    /* align-self: flex-start; */ /* Aligns this item to the start of the cross axis (top) */
    /* margin-left: auto; */    /* Pushes this item to the right */
    /* You might need to adjust padding in #report to make space for this. */
}

  /* Hover/Focus states for visual feedback (for mouse and D-Pad) */
  #report1:hover,
  #report1:focus {
    display: none;
    cursor: pointer; /* Indicates it's interactive */
    background-color: #66BB6A; /* Lighter green on hover/focus */
    transform: translateY(-2px); /* Subtle lift */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
  }

  /* State when the report is "disabled" or hidden to reveal other buttons */
  /* This class will be added by JavaScript */
  #report1.hidden {
    opacity: 0; /* Makes it fully transparent */
    pointer-events: none; /* Prevents clicks/interactions when hidden */
    transform: translateY(100%); /* Moves it out of view downwards */
    z-index: -1; /* Puts it behind other content when hidden, making underlying elements clickable */
  }
    #xreport {
    /* Positioning for the bottom-left corner */
    position: fixed; /* Stays in place relative to the viewport */
    bottom: 0%;
    left: 0;
    z-index: 3; /* Ensures it's on top of other content normally */

    /* Initial size and trapezium shape */
    width: 244px; /* Adjust as needed */
    height: 58px;  /* Adjust as needed */
    background-color: #388E3C; /* Base green color */
    clip-path: polygon(0 100%, 0 0, 100% 0, 80% 100%); /* Defines the trapezium shape */
    /* For a more precise trapezium, you might need to adjust the last point's X-coordinate */

    /* Border for the trapezium */
    border-bottom: 2.4px solid #4CAF50; /* Different green border color */
    border-left: 2.4px solid #4CAF50;
    /* Only bottom and left for a clean look, adjust as needed */

    /* Text styling */
    color: white; /* Text color */
    font-family: "Cairo", sans-serif;
    font-optical-sizing: auto;
    font-weight: 800;
    font-style: normal;
    font-variation-settings:
    "slnt" 0;
    font-size: 0.9em; /* Adjust text size */
    display: flex; /* Use flexbox for text positioning */
    justify-content: center; /* Centers the content initially */
    margin-right: -2%; 
    align-items: flex-start; /* Aligns content to the top */
    padding: 1px; /* Padding for the text inside the trapezium */
    box-sizing: border-box; /* Include padding in width/height */

    /* Make it focusable (important for D-Pad) */
    tabindex: 0; /* Allows the div to receive focus */
    outline: none; /* Remove default focus outline if desired, but be careful with accessibility */

    /* Smooth transition for hiding/showing */
    transition: all 0.3s ease-in-out; /* Smooth transition for property changes */

    /* Ensure initial text positioning (adjust margin-right if needed) */
    /* The `margin-right: -2%;` from your sample pushes the content right.
       If you want the text "Booking number: 1" to appear on the "top of background area and very right of the background area" as per your original prompt,
       you might adjust `justify-content` and `align-items` more.
       For "very right and top":
       justify-content: flex-end;
       align-items: flex-start;
       But your current `justify-content: center;` combined with `margin-right: -2%;` might be your desired visual.
       I'll keep your provided `justify-content: center;` for now.
    */
}

/* Style for the text inside the report div */
#xreport::before {
    /* If you want this specifically to the very right and top of the trapezium: */
    /* align-self: flex-start; */ /* Aligns this item to the start of the cross axis (top) */
    /* margin-left: auto; */    /* Pushes this item to the right */
    /* You might need to adjust padding in #report to make space for this. */
}

/* Hover/Focus states for visual feedback (for mouse and D-Pad) */
#xreport:hover,
#xreport:focus {
    cursor: pointer; /* Indicates it's interactive */
    background-color: #66BB6A; /* Lighter green on hover/focus */
    transform: translateY(-2px); /* Subtle lift */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
}

/* State when the report is "disabled" or hidden to reveal other buttons */
/* This class will be added by JavaScript */
#xreport.hidden {
    opacity: 0; /* Makes it fully transparent */
    pointer-events: none; /* Prevents clicks/interactions when hidden */
    transform: translateY(100%); /* Moves it out of view downwards */
    z-index: -1; /* Puts it behind other content when hidden, making underlying elements clickable */
}
      #report {
        /* Positioning for the bottom-left corner */
        position: fixed; /* Stays in place relative to the viewport */
        bottom: 1%;
        right: 1%;
        z-index: 4; /* Ensures it's on top of other content normally */

        /* Initial size and trapezium shape */
        width: 260px; /* Adjust as needed */
        height: 35px; /* Adjust as needed */
        background-color: #ffffff; /* Base green color */
        clip-path: polygon(100% 100%, 100% 0, 0 0, 20% 100%);
        /* For a more precise trapezium, you might need to adjust the last point's X-coordinate */

        /* Border for the trapezium */
        border-bottom: 16px solid #4caf50; /* Different green border color */
        border-left: 16px solid #4caf50
        opacity: 30%;
        /* Only bottom and left for a clean look, adjust as needed */

       /* Text styling */
        bottom: 1%;
        color: #000000; /* Text color4caf50 */
        font-family: "Tajawal", sans-serif;
        font-weight: 800;
        font-style: normal;
        font-variation-settings: "slnt" 0;
        font-size: 0.8em; /* Adjust text size */
        display: flex; /* Use flexbox for text positioning */
        justify-content: center; /* Centers the content initially */
        margin-right: -1%;
        align-items: center; /* Align items to the center vertically as well */
        padding: 8px; /* Padding for the text inside the trapezium */
        box-sizing: border-box; /* Include padding in width/height */

        /* Smooth transition for hiding/showing */
        transition: all 0.3s ease-in-out; /* Smooth transition for property changes */

        /* Remove default button styling */
        border: none; /* Remove default button border */
        cursor: pointer; /* Ensure the cursor indicates it's clickable */
      }

      /* Style for the text inside the report div */
      #report::before {
        /* If you want this specifically to the very right and top of the trapezium: */
        /* align-self: flex-start; */ /* Aligns this item to the start of the cross axis (top) */
        /* margin-left: auto;     */ /* Pushes this item to the right */
        /* You might need to adjust padding in #report to make space for this. */
      }

      /* Hover/Focus states for visual feedback (for mouse and D-Pad) */
      #report:hover,
      #report:focus {
        background-color: #66bb6a; /* Lighter green on hover/focus */
        transform: translateY(-2px); /* Subtle lift */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
        outline: 2px solid #4caf50; /* Add a visible outline for focus, if you removed the default */
        outline-offset: 2px; /* Add some space between the outline and the button */
      }

      /* State when the report is "disabled" or hidden to reveal other buttons */
      /* This class will be added by JavaScript */
      #report.hidden {
        opacity: 0; /* Makes it fully transparent */
        pointer-events: none; /* Prevents clicks/interactions when hidden */
        transform: translateY(100%); /* Moves it out of view downwards */
        z-index: -1; /* Puts it behind other content when hidden, making underlying elements clickable */
      }
    /* TV UPDATE: Removed #rraudio as it's not in the HTML and was likely a typo or old style */
      #sreport {
        /* Positioning for the bottom-left corner */
        position: fixed; /* Stays in place relative to the viewport */
        bottom: 1%;
        left: 0%;
        z-index: 4; /* Ensures it's on top of other content normally */

        /* Initial size and trapezium shape */
        width: 260px; /* Adjust as needed */
        height: 35px; /* Adjust as needed */
        background-color: #ffffff; /* Base green color */
        clip-path: polygon(0% 100%, 0% 0%, 100% 0%, 80% 100%);
        /* For a more precise trapezium, you might need to adjust the last point's X-coordinate */

        /* Border for the trapezium */
        border-bottom: 16px solid #4caf50; /* Different green border color */
        border-left: 16px solid #4caf50
        opacity: 30%;
        /* Only bottom and left for a clean look, adjust as needed */

       /* Text styling */
        bottom: 1%;
        color: #000000; /* Text color4caf50 */
        font-family: "Tajawal", sans-serif;
        font-weight: 800;
        font-style: normal;
        font-variation-settings: "slnt" 0;
        font-size: 1em; /* Adjust text size */
        display: flex; /* Use flexbox for text positioning */
        justify-content: center; /* Centers the content initially */
        margin-right: -1%;
        align-items: center; /* Align items to the center vertically as well */
        padding: 8px; /* Padding for the text inside the trapezium */
        box-sizing: border-box; /* Include padding in width/height */

        /* Smooth transition for hiding/showing */
        transition: all 0.3s ease-in-out; /* Smooth transition for property changes */

        /* Remove default button styling */
        border: none; /* Remove default button border */
        cursor: pointer; /* Ensure the cursor indicates it's clickable */
      }

      /* Style for the text inside the report div */
      #sreport::before {
        /* If you want this specifically to the very right and top of the trapezium: */
        /* align-self: flex-start; */ /* Aligns this item to the start of the cross axis (top) */
        /* margin-left: auto;     */ /* Pushes this item to the right */
        /* You might need to adjust padding in #report to make space for this. */
      }

      /* Hover/Focus states for visual feedback (for mouse and D-Pad) */
      #sreport:hover,
      #sreport:focus {
        background-color: #66bb6a; /* Lighter green on hover/focus */
        transform: translateY(-2px); /* Subtle lift */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Subtle shadow */
        outline: 2px solid #4caf50; /* Add a visible outline for focus, if you removed the default */
        outline-offset: 2px; /* Add some space between the outline and the button */
      }

      /* State when the report is "disabled" or hidden to reveal other buttons */
      /* This class will be added by JavaScript */
      #sreport.hidden {
        opacity: 0; /* Makes it fully transparent */
        pointer-events: none; /* Prevents clicks/interactions when hidden */
        transform: translateY(100%); /* Moves it out of view downwards */
        z-index: -1; /* Puts it behind other content when hidden, making underlying elements clickable */
      }
    /* TV UPDATE: Removed #rraudio as it's not in the HTML and was likely a typo or old style */



.cairo-<uniquifier> {
  font-family: "Cairo", sans-serif;
  font-optical-sizing: auto;
  font-weight: 800;
  font-style: normal;
  font-variation-settings:
    "slnt" 0;
}
    .translation {
        margin-top: 10px;
        font-family: "Roboto", sans-serif;
        font-optical-sizing: auto;
        font-weight: 500;
        font-style: normal;
        font-variation-settings:
        "wdth" 100;
        /* font-size: 1.5em; */ /* Remove the fixed font-size from CSS */
        color: #ffffff ;
        padding: 10px;
        border-top: 1px solid #ddd;
        max-width: 80%;
        margin: 10px auto;
        text-align: center;
        transition: opacity 1s ease-in-out, filter 2s ease-in-out;
        /* Add these for better overflow handling */
        overflow-wrap: break-word; /* Allows long words to break */
        word-wrap: break-word; /* Older browsers */
    }

.dark-mode .translation {
        color: #ffffff;
    }

    
    /* TV UPDATE: Removed duplicated #translation style block */
    /* TV UPDATE: Removed duplicated body transition and dark-mode, already defined */
    /* TV UPDATE: Removed duplicated #f4f4f4; (incomplete style) */
    /* TV UPDATE: Removed duplicated #audio { display: none; } */

#play-pause {
    display: none;
    position: fixed; /* TV UPDATE: Consider if fixed is best */
    bottom: 2%;
    right: 95px;
    padding: 1px 2px; /* TV UPDATE: Adjusted padding */
    font-family: "Cairo", sans-serif;
    font-optical-sizing: auto;
    font-weight: 800;
    font-size: 18px;
    background-color: #5E5E5D;
    opacity: .8; /* TV UPDATE: Slightly more opaque */
    color: white;
    border: none;
    border-radius: 5px; /* TV UPDATE: Consistent radius */
    cursor: pointer;
    z-index: 3;
}
#play-pause:hover, #play-pause:focus { /* TV UPDATE: Added focus state for hover effect */
    background-color: #008000;
}

    #hideS, #hideA, #darkModeToggle { /* TV UPDATE: Grouped common styles */
      position: fixed; /* TV UPDATE: Consider if fixed is best */
      bottom: 2%;
      padding: 1px 4px; /* TV UPDATE: Adjusted padding */
      font-family: "Cairo", sans-serif;
      font-optical-sizing: auto;
      font-weight: 800;
      font-size: 8px;
      background-color: #5E5E5D;
      opacity: .8; /* TV UPDATE: Slightly more opaque */
      color: white;
      border: none;
      border-radius: 5px; /* TV UPDATE: Consistent radius */
      cursor: pointer;
      z-index: 2;
    }
    #hideS { right: 23px; /* TV UPDATE: Adjusted positioning relative to play/pause */ }
    #hideA { right: 53px; /* TV UPDATE: Adjusted positioning */ }
    #darkModeToggle { right: 75px; /* TV UPDATE: Adjusted positioning */ }


    #hideS:hover, #hideS:focus, /* TV UPDATE: Added focus state */
    #hideA:hover, #hideA:focus { /* TV UPDATE: Added focus state */
    #darkModeToggle:hover, #darkModeToggle:focus { /* TV UPDATE: Added focus state */
      background-color: #008000;
    }
  .hidden {
    display: none !important;
  }


    /* TV UPDATE: Removed duplicated @font-face for Verdana */
    /* TV UPDATE: option.style1, option.style2, #option styles seemed unused or could be simplified if needed */

    /* TV UPDATE: Explicitly make selects focusable if default isn't enough, though they should be */
    select {
        /* tabindex: 0; /* Usually not needed, but can ensure */
    }
.poppins-regular {
  font-family: "Poppins", sans-serif;
  font-weight: 400;
  font-style: normal;
}

.poppins-medium {
  font-family: "Poppins", sans-serif;
  font-weight: 500;
  font-style: normal;
}

.signika-<uniquifier> {
  font-family: "Signika", sans-serif;
  font-optical-sizing: auto;
  font-weight: 470;
  font-style: normal;
  font-variation-settings:
    "GRAD" 0;
}

.montserrat-<uniquifier> {
  font-family: "Montserrat", sans-serif;
  font-optical-sizing: auto;
  font-weight: 700;
  font-style: normal;
}
  #loading {
    display: none; /* Hidden by default */
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 20px;
    color: blue;
  }
.almarai-extrabold {
  font-family: "Almarai", sans-serif;
  font-weight: 800;
  font-style: normal;
}
.roboto-<uniquifier> {
  font-family: "Roboto", sans-serif;
  font-optical-sizing: auto;
  font-weight: 500;
  font-style: normal;
  font-variation-settings:
    "wdth" 100;
}
.tajawal-extrabold {
  font-family: "Tajawal", sans-serif;
  font-weight: 800;
  font-style: normal;
}


  </style>
</head>

<body>
  <!-- TV UPDATE: Buttons should be focusable by default, ensure they are in logical DOM order for navigation -->
  <button id="darkModeToggle" aria-label="Toggle Dark Mode"> <!-- TV UPDATE: Added aria-label for accessibility -->
   <i class="fas fa-sun"></i>
    <i class="fas fa-moon" style="display: none;"></i>
  </button>
<div id="loadingOverlay" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2em;
    z-index: 9999;
    display: none; /* Hidden by default */
">
    Loading...
</div>



<script>
const play-pause = document.getElementById('play-pause');

play-pause.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
        if (audio.paused) {
            audio.play();
            playPauseButton.classList.remove('fa-play');
            playPauseButton.classList.add('fa-pause');
            playPauseButton.setAttribute('aria-label', 'Pause Audio');
        } else {
            audio.pause();
            playPauseButton.classList.remove('fa-pause');
            playPauseButton.classList.add('fa-play');
            playPauseButton.setAttribute('aria-label', 'Play Audio');
        }
    }
});

// You'll also need your existing JavaScript to handle the button's click event
play-pause.addEventListener('click', function() {
    // Your code to toggle dark mode goes here
    console.log('play-pause toggled!'); // Example action
});
</script>
<script>
  const darkModeToggle = document.getElementById('darkModeToggle');

  darkModeToggle.addEventListener('keydown', function(event) {
    if (event.key === 'Enter') {
      // Simulate a click on the button
      this.click();
    }
  });

  // You'll also need your existing JavaScript to handle the button's click event
  darkModeToggle.addEventListener('click', function() {
    // Your code to toggle dark mode goes here
    console.log('Dark mode toggled!'); // Example action
  });
</script>
    <script>
      const reportButton = document.getElementById("report");

      reportButton.addEventListener("click", () => {
        // This function will be executed when the button is clicked or activated
        // (e.g., by pressing Enter/Space when focused).
        alert("Report button clicked!"); // Replace with your actual functionality
        // You could also add or remove classes here, e.g.:
        // reportButton.classList.toggle('hidden');
      });

      // If you are using JavaScript to make a DIV clickable (less recommended):
      /*
      // For a DIV, you'd also need to listen for keydown events
      reportButton.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') { // ' ' is for spacebar
              event.preventDefault(); // Prevent default scroll behavior for spacebar
              reportButton.click(); // Trigger the click event
          }
      });
      */
    </script>
<button id="report" aria-label="Generate Report"></button>
<script>
    let currentTemperatureMedina = "Fetching..."; // Variable to store Medina temperature
    let currentTemperatureMecca = "Fetching..."; // Variable to store Mecca temperature

    // Function to fetch Medina temperature
    async function fetchTemperatureMedina() {
        const latitude = 24.47; // Medina latitude
        const longitude = 39.61; // Medina longitude
        const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&current_weather=true`;

        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            if (data && data.current_weather && data.current_weather.temperature !== undefined) {
                currentTemperatureMedina = `${Math.round(data.current_weather.temperature)}°C`;
            } else {
                currentTemperatureMedina = "N/A";
            }
        } catch (error) {
            console.error("Error fetching Medina temperature:", error);
            currentTemperatureMedina = "Error";
        }
    }

    // Function to fetch Mecca temperature
    async function fetchTemperatureMecca() {
        const latitude = 21.42; // Mecca latitude
        const longitude = 39.82; // Mecca longitude
        const apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m&current_weather=true`;

        try {
            const response = await fetch(apiUrl);
            const data = await response.json();
            if (data && data.current_weather && data.current_weather.temperature !== undefined) {
                currentTemperatureMecca = `${Math.round(data.current_weather.temperature)}°C`;
            } else {
                currentTemperatureMecca = "N/A";
            }
        } catch (error) {
            console.error("Error fetching Mecca temperature:", error);
            currentTemperatureMecca = "Error";
        }
    }

    // Fetch temperatures initially and then every 10 minutes (600,000 milliseconds)
    fetchTemperatureMedina();
    fetchTemperatureMecca();
    setInterval(fetchTemperatureMedina, 600000);
    setInterval(fetchTemperatureMecca, 600000);


    function updateReport2() {
        const now = new Date();

        // --- Time Formatting (Arabic Numbers with AM/PM) ---
        const timeFormatter = new Intl.DateTimeFormat('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: true,
            timeZone: 'Asia/Riyadh'
        });
        const timeString = timeFormatter.format(now);

        // --- Hijri Date Formatting (Arabic Letters and Numbers) ---
        const hijriDateFormatter = new Intl.DateTimeFormat('ar-SA', {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
            calendar: 'islamic-umalqura',
            timeZone: 'Asia/Riyadh'
        });

        let hijriDateString = hijriDateFormatter.format(now);
        hijriDateString = hijriDateString.replace(' AH', '').trim();
        if (!hijriDateString.endsWith('هـ')) {
            hijriDateString += 'هـ';
        }

        // --- Update Display ---
        const currentSeconds = now.getSeconds();
        const displayElement = document.getElementById("report");

        // Rotate between time, Hijri date, Medina temperature, Mecca temperature, and current chapter title
        if (currentSeconds >= 0 && currentSeconds < 12) { // Display time for 12 seconds
            displayElement.textContent = timeString;
        } else if (currentSeconds >= 12 && currentSeconds < 24) { // Display Hijri date for 12 seconds
            displayElement.textContent = hijriDateString;
        } else if (currentSeconds >= 24 && currentSeconds < 36) { // Display Medina temperature for 12 seconds
            displayElement.textContent = `Medina | ${currentTemperatureMedina}`;
        } else if (currentSeconds >= 36 && currentSeconds < 48) { // Display Mecca temperature for 12 seconds
            displayElement.textContent = `Mecca | ${currentTemperatureMecca}`;
        } else { // Display current chapter title for the last 12 seconds
            if (typeof currentChapterData !== 'undefined' && currentChapterData.title) {
                displayElement.textContent = currentChapterData.title;
            } else {
                displayElement.textContent = "Chapter information not available";
            }
        }
    }


    // Update initially
    updateReport2();

    // Update every second
    setInterval(updateReport2, 1000);
</script>





  <button id="play-pause" class="fa fa-play" aria-label="Play or Pause Audio"></button> <!-- TV UPDATE: Added aria-label -->
  <button id="hideS" onclick="myFunction()" aria-label="Toggle Surah Selector">سورة</button> <!-- TV UPDATE: Added aria-label -->
  <button id="hideA" onclick="mybFunction()" aria-label="Toggle Ayat Selector">آية</button> <!-- TV UPDATE: Added aria-label -->

<script>
function myFunction() {
  var selectElement = document.getElementById("chapterSelect");
  var labelElement = document.getElementById("chapterSelectLabel"); // Get the label element

  if (selectElement.style.display === "none") {
    selectElement.style.display = "block";
    labelElement.style.display = "block"; // Show the label
    selectElement.focus();
  } else {
    selectElement.style.display = "none";
    labelElement.style.display = "none"; // Hide the label
  }
}
</script>
<script>
function mybFunction() {
  var selectElement = document.getElementById("verseSelect");
  var labelElement = document.getElementById("verseSelectLabel"); // Get the label element

  if (selectElement.style.display === "none") {
    selectElement.style.display = "block";
    labelElement.style.display = "block"; // Show the label
    selectElement.focus();
  } else {
    selectElement.style.display = "none";
    labelElement.style.display = "none"; // Hide the label
  }
}
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const reportButton = document.getElementById('report');
    const backgroundButtonsContainer = document.getElementById('button-container');
    const backgroundButtons = backgroundButtonsContainer ?
        backgroundButtonsContainer.querySelectorAll('.background-button') :
        document.querySelectorAll('.background-button');
    const audioPlayer = document.getElementById('audio'); // Assuming your audio element has id="audio"

    let isReportVisible = true;
    let audioPlayingTimer = null; // Timer for the 1-minute delay when audio is playing and report is clicked
    let isAudioPlaying = false; // Track audio playback state

    // --- Utility Functions ---

    // Function to hide the report and enable background buttons
    const hideReport = () => {
        if (isReportVisible) {
            reportButton.classList.add('hidden');
            backgroundButtons.forEach(btn => {
                btn.removeAttribute('tabindex');
                btn.style.pointerEvents = 'auto';
            });
            isReportVisible = false;
            if (backgroundButtons.length > 0) {
                backgroundButtons[0].focus();
            }
        }
    };

    // Function to show the report and disable background buttons
    const showReport = () => {
        if (!isReportVisible) {
            reportButton.classList.remove('hidden');
            backgroundButtons.forEach(btn => {
                btn.tabIndex = -1;
                btn.style.pointerEvents = 'none';
            });
            isReportVisible = true;
            reportButton.focus();
        }
    };

    // --- Audio Logic ---

    // Function to check if audio is currently playing
    const checkAudioPlayback = () => {
        return audioPlayer && !audioPlayer.paused && audioPlayer.currentTime > 0;
    };

    // Event listener for when audio starts playing
    if (audioPlayer) {
        audioPlayer.addEventListener('play', () => {
            isAudioPlaying = true;
            console.log('Audio started playing. Showing report.');
            showReport(); // Always show if audio starts playing
            // Clear any existing timer if audio starts playing again
            if (audioPlayingTimer) {
                clearTimeout(audioPlayingTimer);
                audioPlayingTimer = null;
            }
        });

        // Event listener for when audio is paused or stops
        audioPlayer.addEventListener('pause', () => {
            isAudioPlaying = false;
            console.log('Audio paused. Hiding report.');
            hideReport(); // Hide if audio pauses/stops
            // Clear any existing timer
            if (audioPlayingTimer) {
                clearTimeout(audioPlayingTimer);
                audioPlayingTimer = null;
            }
        });

        audioPlayer.addEventListener('ended', () => {
            isAudioPlaying = false;
            console.log('Audio ended. Hiding report.');
            hideReport(); // Hide if audio ends
            // Clear any existing timer
            if (audioPlayingTimer) {
                clearTimeout(audioPlayingTimer);
                audioPlayingTimer = null;
            }
        });
    }

    // --- Initial Setup and Event Listeners ---

    // Initial setup: ensure background buttons are unfocusable when report is visible
    backgroundButtons.forEach(btn => {
        btn.tabIndex = -1;
        btn.style.pointerEvents = 'none';
    });

    // Event listener for when the report button is "clicked" (Enter key on D-Pad or actual mouse click)
    reportButton.addEventListener('click', () => {
        if (isAudioPlaying) {
            console.log('Report clicked while audio playing. Hiding for 1 minute.');
            hideReport();
            // Start a 1-minute timer to show the report again
            if (audioPlayingTimer) {
                clearTimeout(audioPlayingTimer); // Clear previous timer if clicked again
            }
            audioPlayingTimer = setTimeout(() => {
                console.log('1 minute passed. Showing report again.');
                showReport();
                audioPlayingTimer = null; // Reset timer
            }, 15 * 1000); // 15 seconds in milliseconds
        } else {
            console.log('Report clicked, audio not playing. Hiding immediately.');
            hideReport(); // Hide immediately if audio is not playing
        }
    });

    // Handle D-Pad navigation *away* from the report button.
    reportButton.addEventListener('blur', () => {
        setTimeout(() => {
            const activeElement = document.activeElement;
            let isFocusOnBackgroundButton = false;

            backgroundButtons.forEach(btn => {
                if (btn === activeElement) {
                    isFocusOnBackgroundButton = true;
                }
            });

            // If focus is not on a background button AND the report is currently hidden,
            // and audio is NOT playing, then re-show the report.
            // If audio is playing, the audio 'play' event listener will handle showing.
            if (!isFocusOnBackgroundButton && !isReportVisible && !isAudioPlaying) {
                console.log('Focus moved away and audio not playing. Showing report.');
                showReport();
            }
        }, 50);
    });

    // You might also need a mechanism to re-show the report if the user navigates
    // away from ALL background buttons.
    backgroundButtons.forEach(btn => {
        btn.addEventListener('blur', () => {
            setTimeout(() => {
                const activeElement = document.activeElement;
                let isFocusOnReport = (activeElement === reportButton);
                let isFocusOnBackgroundButton = false;

                backgroundButtons.forEach(b => {
                    if (b === activeElement) {
                        isFocusOnBackgroundButton = true;
                    }
                });

                // If focus is not on the report, and not on any background button,
                // and the report is currently hidden, and audio is NOT playing, then show the report again.
                if (!isFocusOnReport && !isFocusOnBackgroundButton && !isReportVisible && !isAudioPlaying) {
                    console.log('Focus moved away from all background buttons and audio not playing. Showing report.');
                    showReport();
                }
            }, 50);
        });
    });

    // Add event listeners to background buttons to handle their clicks
    backgroundButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            console.log(`Background button clicked: ${btn.textContent}`);
            // You might want to re-evaluate showing the report after a background button action
            // depending on your specific UX. For now, it respects the audio playback rules.
        });
    });

    // Initial check for audio playback state on load
    if (checkAudioPlayback()) {
        isAudioPlaying = true;
        console.log('Audio already playing on load. Showing report.');
        showReport();
    } else {
        isAudioPlaying = false;
        console.log('Audio not playing on load. Hiding report (initial state).');
        hideReport(); // Hide if audio is not playing initially
    }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', (event) => {
    const audioPlayer = document.getElementById('audio');
    const chapterSelect = document.getElementById('chapterSelect');
    const chapterSelectLabel = document.getElementById('chapterSelectLabel');
    const verseSelect = document.getElementById('verseSelect');
    const verseSelectLabel = document.getElementById('verseSelectLabel');

    const elementsToWatch = [
      chapterSelect,
      chapterSelectLabel,
      verseSelect,
      verseSelectLabel
    ];

    let hideElementsTimeout;
    let forcedVisibilityActive = false; // Flag to indicate if elements are forced visible

    function showElements() {
      elementsToWatch.forEach(el => el.style.display = 'block');
    }

    function hideElements() {
      elementsToWatch.forEach(el => el.style.display = 'none');
    }

    // This function handles the logic for starting the 20-second re-hide timer
    function activateForcedVisibilityTimer() {
      if (!audioPlayer.paused && !audioPlayer.ended) { // Only if audio is playing
        forcedVisibilityActive = true;
        clearTimeout(hideElementsTimeout); // Clear any existing timeout

        hideElementsTimeout = setTimeout(() => {
          forcedVisibilityActive = false; // Reset the flag
          toggleElementsVisibility(); // Re-evaluate visibility based on audio state
        }, 10000); // 20 seconds
      }
    }

    function toggleElementsVisibility() {
      if (forcedVisibilityActive) {
        // If forced visibility is active, don't hide based on audio state immediately
        return;
      }

      if (audioPlayer.paused || audioPlayer.ended) {
        // Audio is paused or ended, show the elements
        showElements();
        clearTimeout(hideElementsTimeout); // Clear any pending hide timeouts if audio stops
      } else {
        // Audio is playing, hide the elements
        hideElements();
      }
    }

    // --- Mutation Observer Setup ---
    const observerCallback = function(mutationsList, observer) {
      for (const mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
          // Check if the 'display' style was changed to anything other than 'none'
          const targetElement = mutation.target;
          if (targetElement.style.display !== 'none' && !audioPlayer.paused && !audioPlayer.ended) {
            // An element became visible while audio is playing
            console.log(`Detected visibility change for: ${targetElement.id}. Starting 20s timer.`);
            activateForcedVisibilityTimer();
            break; // No need to process other mutations if one triggered the timer
          }
        }
      }
    };

    const observerConfig = { attributes: true, attributeFilter: ['style'] };

    // Create and start an observer for each of the target elements
    elementsToWatch.forEach(el => {
      if (el) { // Ensure the element exists before observing
        const observer = new MutationObserver(observerCallback);
        observer.observe(el, observerConfig);
      } else {
        console.warn(`Element with ID '${el ? el.id : 'unknown'}' not found, cannot observe.`);
      }
    });

    // --- Initial State and Audio Event Listeners ---

    // Initial check when the page loads
    toggleElementsVisibility();

    // Event listeners for audio play, pause, and ended events
    audioPlayer.addEventListener('play', toggleElementsVisibility);
    audioPlayer.addEventListener('pause', toggleElementsVisibility);
    audioPlayer.addEventListener('ended', toggleElementsVisibility);
  });
</script>








  <!-- TV UPDATE: Consider if an H1 title is useful for context on the TV screen -->
  <!-- <h1>Qur'an Recitation</h1> -->

  <div class="parentContainer">
    <label for="chapterSelect" id="chapterSelectLabel"></label> <!-- TV UPDATE: More descriptive label -->
    <select id="chapterSelect" onchange="loadAudio()">
      <option value="" class="style1">سورة</option>
    </select>

    <label for="verseSelect" id="verseSelectLabel"></label> <!-- TV UPDATE: More descriptive label -->
    <select id="verseSelect" onchange="seekToSelectedVerse()">
      <option value="" class="style1">آية</option>
    </select>
  </div>
  <div id="verseImageContainer"></div>
  <div id="translation" class="translation"></div>

  <div id="audio-container" class="loading">
    <div id="loading"></div>
    <audio id="audio" controls> <!-- Controls attribute might be hidden by CSS but useful for debugging if needed -->
      <source id="audioSource" type="audio/mp3">
      Your browser does not support the audio element.
    </audio>
  </div>
<div id="loaderContainer" class="loader-container">
  <div class="loader"></div>
</div>

<script>
    const audio = document.getElementById('audio');
    const playPauseButton = document.getElementById('play-pause');

    playPauseButton.addEventListener('click', () => {
        if (audio.paused) {
            audio.play();
            playPauseButton.classList.remove('fa-play');
            playPauseButton.classList.add('fa-pause');
            playPauseButton.setAttribute('aria-label', 'Pause Audio');
        } else {
            audio.pause();
            playPauseButton.classList.remove('fa-pause');
            playPauseButton.classList.add('fa-play');
            playPauseButton.setAttribute('aria-label', 'Play Audio');
        }
    });

    audio.onplay = function() {
        playPauseButton.classList.remove('fa-play');
        playPauseButton.classList.add('fa-pause');
        playPauseButton.setAttribute('aria-label', 'Pause Audio');
    };
    audio.onpause = function() {
        playPauseButton.classList.remove('fa-pause');
        playPauseButton.classList.add('fa-play');
        playPauseButton.setAttribute('aria-label', 'Play Audio');
    };

    const toggleButton = document.getElementById('darkModeToggle');
    const sunIcon = toggleButton.querySelector('.fa-sun');
    const moonIcon = toggleButton.querySelector('.fa-moon');

    function applyTheme(isDarkMode) {
        const reportElement = document.getElementById('report'); // Get the report element
        if (isDarkMode) {
            document.body.classList.remove('light-mode');
            document.body.classList.add('dark-mode');
            sunIcon.style.display = 'none';
            moonIcon.style.display = 'inline-block';
            toggleButton.setAttribute('aria-label', 'Switch to Light Mode');
            if (reportElement) { // Check if the element exists before trying to style it
                reportElement.style.backgroundColor = '#ffffff';    // #3C4043
            }
        } else {
            document.body.classList.remove('dark-mode');
            document.body.classList.add('light-mode');
            sunIcon.style.display = 'inline-block';
            moonIcon.style.display = 'none';
            toggleButton.setAttribute('aria-label', 'Switch to Dark Mode');
            if (reportElement) { // Check if the element exists before trying to style it
                reportElement.style.backgroundColor = '#ffffff';
            }
        }
    }

    function forceDarkMode() {
        const fragment = window.location.hash;
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        // TV UPDATE: Simplified logic, #0 forces light, otherwise prefer system, default to dark
        if (fragment === "#0") {
            applyTheme(false); // Force light
        } else {
            applyTheme(prefersDark); // System preference or default to dark (initial class on body)
        }
    }
    // TV UPDATE: Initialize body with a default theme to avoid flash if JS is slow
    document.body.classList.add('dark-mode'); // Default to dark, forceDarkMode will adjust
    forceDarkMode();

    toggleButton.addEventListener('click', () => {
        const isCurrentlyDarkMode = document.body.classList.contains('dark-mode');
        applyTheme(!isCurrentlyDarkMode);
    });

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        // Only apply if not forced by #0
        if (window.location.hash !== "#0") {
            applyTheme(e.matches);
        }
    });

    let jsonData = null;
    let translationXMLData = null; // Changed to hold XML Document
    let currentChapterData = null;
    let currentChapterIndex = 0;

    fetch('https://muslim1446.github.io/a/2TM3TM.json')
        .then(response => response.json())
        .then(data => {
            jsonData = data;
            populateChapterSelect();
            checkUrlParamsAndLocalStorage(); // TV UPDATE: Combined function
        })
        .catch(error => console.error('Error fetching JSON:', error));

    // --- MODIFICATION START ---
    fetch('https://muslim1446.github.io/a/3TM.xml') // Assuming 3TM.json is now your XML file
        .then(response => response.text()) // Fetch as text
        .then(xmlString => {
            const parser = new DOMParser();
            translationXMLData = parser.parseFromString(xmlString, 'application/xml'); // Parse as XML
        })
        .catch(error => console.error('Error fetching XML:', error));
    // --- MODIFICATION END ---

    function populateChapterSelect() {
        const chapterSelect = document.getElementById('chapterSelect');
        jsonData.chapters.forEach((chapter, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = ` (${chapter.chapterNumber}) ${chapter.title} `;
            chapterSelect.appendChild(option);
        });
    }

    // TV UPDATE: Combined URL and localStorage checking
    function checkUrlParamsAndLocalStorage() {
        const urlParams = new URLSearchParams(window.location.search);
        let surahToLoad = urlParams.get('surah');
        let ayatToLoad = urlParams.get('ayat');
        let loadedFromUrl = false;

        if (surahToLoad) {
            const surahIndex = parseInt(surahToLoad) - 1;
            if (jsonData && jsonData.chapters[surahIndex]) {
                document.getElementById('chapterSelect').value = surahIndex;
                loadChapterAudio(surahIndex, ayatToLoad); // Pass ayatToLoad here
                loadedFromUrl = true;
            }
        }

        if (!loadedFromUrl) {
            const storedChapterIndex = localStorage.getItem('currentChapterIndex');
            const storedAyatIndex = localStorage.getItem('currentAyatIndex');
            if (storedChapterIndex !== null && jsonData && jsonData.chapters[storedChapterIndex]) {
                document.getElementById('chapterSelect').value = storedChapterIndex;
                loadChapterAudio(parseInt(storedChapterIndex), storedAyatIndex); // Pass ayat here
            }
        }
        // Theme from URL hash
        if (window.location.hash === "#0") {
            applyTheme(false); // Force light
        }
    }

    function loadAudio() { // This is called by onchange of chapterSelect
        const chapterSelect = document.getElementById('chapterSelect');
        const selectedChapterIndex = chapterSelect.value;
        if (selectedChapterIndex !== "") {
            loadChapterAudio(parseInt(selectedChapterIndex), null); // Load chapter, ayat will be 1 or from selection
        }
    }

    function loadChapterAudio(index, targetAyat = null) {
        if (!jsonData || !jsonData.chapters[index]) {
            console.error("Chapter data not available for index:", index);
            return;
        }
        const chapter = jsonData.chapters[index];
        const audioSource = document.getElementById('audioSource');
        audioSource.src = chapter.audioURL;

        const audioPlayer = document.getElementById('audio');
        audioPlayer.load();
        audioPlayer.play().catch(e => console.error("Audio play error:", e)); // TV UPDATE: Catch play errors

        currentChapterData = chapter;
        currentChapterIndex = index;
        updateVerseSelect();

        // TV UPDATE: Logic to set initial verse after loading
        let initialAyat = 1;
        if (targetAyat && chapter.verses.find(v => v.verseNumber == targetAyat)) {
            initialAyat = parseInt(targetAyat);
        }

        const verseSelect = document.getElementById('verseSelect');
        verseSelect.value = initialAyat; // Set select dropdown value
        // Display initial verse and translation
        displayVersePNG(chapter.chapterNumber, initialAyat);
        displayTranslation(chapter.chapterNumber, initialAyat);

        // Seek audio if it's not the first verse (after metadata loaded)
        if (initialAyat > 1) {
            audioPlayer.onloadedmetadata = () => { // Ensure metadata is loaded before seeking
                const verseData = chapter.verses.find(v => v.verseNumber == initialAyat);
                if (verseData) {
                    const startTimeParts = verseData.startTime.split(':').map(Number);
                    const startTotalSeconds = startTimeParts[0] * 3600 + startTimeParts[1] * 60 + startTimeParts[2];
                    audioPlayer.currentTime = startTotalSeconds;
                }
                audioPlayer.onloadedmetadata = null; // Remove listener
            };
        }

        localStorage.setItem('currentChapterIndex', index);
        localStorage.setItem('currentAyatIndex', initialAyat);
    }

    function updateVerseSelect() {
        const verseSelect = document.getElementById('verseSelect');
        verseSelect.innerHTML = '<option value="" class="style1">Ayat</option>'; // Keep placeholder
        if (currentChapterData) {
            currentChapterData.verses.forEach(verse => {
                const option = document.createElement('option');
                option.value = verse.verseNumber;
                option.textContent = `${verse.verseNumber}`;
                verseSelect.appendChild(option);
            });
        }
    }

    function displayVersePNG(chapNum, verseNum) {
        const verseImageContainer = document.getElementById('verseImageContainer');
        verseImageContainer.innerHTML = '';
        const arabicImg = document.createElement('img');
        arabicImg.src = `https://raw.githubusercontent.com/muslim1446/muslim1446.github.io/refs/heads/master/img/${chapNum}_${verseNum}.png`;
        arabicImg.alt = `Surah ${chapNum}, Verse ${verseNum}`; // TV UPDATE: More descriptive alt
        verseImageContainer.appendChild(arabicImg);
    }

    // --- MODIFICATION START ---
    function displayTranslation(chapNum, verseNum) {
        const translationContainer = document.getElementById('translation');
        translationContainer.innerHTML = '';
        if (translationXMLData) {
            // Find the sura element with the matching index
            const suraElement = translationXMLData.querySelector(`sura[index="${chapNum}"]`);
            if (suraElement) {
                // Find the aya element within that sura with the matching index
                const ayaElement = suraElement.querySelector(`aya[index="${verseNum}"]`);
                if (ayaElement) {
                    const translationText = document.createElement('div');
                    translationText.textContent = ayaElement.getAttribute('text'); // Get the text attribute
                    translationContainer.appendChild(translationText);
                    adjustTranslationFontSize(); // Call the new function here
                }
            }
        }
    }
    // --- MODIFICATION END ---

    // --- Font Adjustment Logic ---
    function adjustTranslationFontSize() {
        const translationContainer = document.getElementById('translation');
        if (!translationContainer) return;

        // Reset font size to a base value for accurate measurement
        // Starting with a slightly larger base helps if the text is short
        let currentEm = 1.8; // Start with a slightly larger base font size
        translationContainer.style.fontSize = `${currentEm}em`;

        const minEm = 0.8; // Allow shrinking to a smaller minimum font size
        const stepEm = 0.05; // Slightly larger step for faster adjustment
        const maxAttempts = 100; // Increase attempts for more thorough shrinking

        // Define a reference width, typically the width of the container.
        // This helps in estimating how much text *should* fit.
        const containerWidth = translationContainer.clientWidth;
        // Get the actual viewport height to help determine vertical overflow
        const viewportHeight = window.innerHeight;

        for (let i = 0; i < maxAttempts; i++) {
            const contentWidth = translationContainer.scrollWidth;
            const contentHeight = translationContainer.scrollHeight;

            // Check for horizontal overflow: content wider than container
            const isOverflowingX = contentWidth > containerWidth + 2; // Add a small buffer

            // Check for vertical overflow more comprehensively:
            // 1. If the content height exceeds the viewport height (meaning a scrollbar will appear)
            // 2. If the content height is significantly more than a reasonable proportion of the viewport height.
            //    A common heuristic for text blocks is that they shouldn't take up too much vertical screen space
            //    if they are expected to fit without scrolling. Let's aim for less than 70% of viewport height.
            const isOverflowingY = contentHeight > (viewportHeight * 0.70) ||
                                    document.documentElement.scrollHeight > viewportHeight + 2; // Overall page scroll

            if (isOverflowingX || isOverflowingY) {
                if (currentEm > minEm) {
                    currentEm -= stepEm;
                    translationContainer.style.fontSize = `${currentEm}em`;
                } else {
                    // Already at minimum font size, cannot reduce further
                    break;
                }
            } else {
                // If it fits, we can break and use this font size.
                // If it was previously too large, we might have over-shrunk slightly.
                // You could add a small increment here to try and get closer to the max size without overflow,
                // but for a "fix" that prioritizes no scrollbar, simply breaking is often sufficient.
                break;
            }
        }
    }
    // --- End Font Adjustment Logic ---

    function updateRealTimeReport() {
        const audio = document.getElementById('audio');
        const currentTime = audio.currentTime;
        let verseChanged = false; // TV UPDATE: Flag to avoid multiple updates for the same verse

        if (currentChapterData) {
            let activeVerseNumber = null;
            for (const verse of currentChapterData.verses) {
                const startTimeParts = verse.startTime.split(':').map(Number);
                const endTimeParts = verse.endTime.split(':').map(Number);
                const startTotalSeconds = startTimeParts[0] * 3600 + startTimeParts[1] * 60 + startTimeParts[2];
                const endTotalSeconds = endTimeParts[0] * 3600 + endTimeParts[1] * 60 + endTimeParts[2];

                if (currentTime >= startTotalSeconds && currentTime <= endTotalSeconds) {
                    activeVerseNumber = verse.verseNumber;
                    // TV UPDATE: Update UI only if the verse has changed
                    if (document.getElementById('verseSelect').value != activeVerseNumber) {
                        document.getElementById('verseSelect').value = activeVerseNumber; // Sync Ayat dropdown
                        displayVersePNG(currentChapterData.chapterNumber, activeVerseNumber);
                        displayTranslation(currentChapterData.chapterNumber, activeVerseNumber); // This will call adjustTranslationFontSize
                        localStorage.setItem('currentAyatIndex', activeVerseNumber); // Persist
                        verseChanged = true;
                    }
                    // Update report regardless of verse change
                    const reportDiv = document.getElementById('ryeport');
                    const reportText = `
                        <strong>Surah ${currentChapterData.title}</strong><br>
                    `; // TV UPDATE: Simplified report
                    reportDiv.innerHTML = reportText;
                    break; // Found the active verse, no need to check others
                }
            }
        }
        updateTitle(); // TV UPDATE: Call title update here as well
    }

    function seekToSelectedVerse() { // Called by onchange of verseSelect
        const verseSelect = document.getElementById('verseSelect');
        const verseNum = parseInt(verseSelect.value);

        if (verseNum && currentChapterData) {
            const verseData = currentChapterData.verses.find(v => v.verseNumber == verseNum);
            if (verseData) {
                const audio = document.getElementById('audio');
                const startTimeParts = verseData.startTime.split(':').map(Number);
                const startTotalSeconds = startTimeParts[0] * 3600 + startTimeParts[1] * 60 + startTimeParts[2];
                audio.currentTime = startTotalSeconds;
                if (audio.paused) { // TV UPDATE: If paused, play when a new verse is selected
                    audio.play().catch(e => console.error("Audio play error:", e));
                }
                displayVersePNG(currentChapterData.chapterNumber, verseNum); // TV UPDATE: Ensure image updates
                displayTranslation(currentChapterData.chapterNumber, verseNum); // TV UPDATE: Ensure translation updates
                localStorage.setItem('currentAyatIndex', verseNum);
            }
        }
    }

    document.getElementById('audio').addEventListener('timeupdate', updateRealTimeReport);

    document.getElementById('audio').addEventListener('ended', function() {
        if (jsonData && currentChapterIndex < jsonData.chapters.length - 1) {
            currentChapterIndex++;
            document.getElementById('chapterSelect').value = currentChapterIndex; // TV UPDATE: Sync dropdown
            loadChapterAudio(currentChapterIndex, 1); // Load next chapter, start at first ayat
        } else {
            // Optional: Indicate end of all chapters, or loop, or stop.
            console.log('You have reached the last chapter or data not loaded.');
            // TV UPDATE: Maybe reset to first chapter or show a message
            // currentChapterIndex = 0; // Example: Loop to first chapter
            // document.getElementById('chapterSelect').value = currentChapterIndex;
            // loadChapterAudio(currentChapterIndex, 1);
        }
    });

    // TV UPDATE: Removed window.onload as DOMContentLoaded and direct calls cover initialization
    // The checkUrlParamsAndLocalStorage is called after JSON is fetched.

    function updateTitle() {
        // TV UPDATE: Simplified title update. Report already shows Surah and Ayat.
        // The MediaSession API handles the system-level title.
        // We can keep the document.title update if desired for browser tabs, but it's less critical for TV.
        if (currentChapterData) {
            const verseSelect = document.getElementById('verseSelect');
            const currentAyat = verseSelect.value || '1'; // Default to 1 if not selected
            document.title = `Qur'an - ${currentChapterData.title} : ${currentAyat}`;
        } else {
            document.title = "Qur'an";
        }
    }
    // TV UPDATE: Removed the setInterval for updateTitle, as updateRealTimeReport calls it.
    // Initial title set after data load and when verse changes.

    // TV UPDATE: Add event listeners to select elements to ensure they get focus styling
    // This is often handled by the browser, but explicit listening can be a fallback.
    document.getElementById('chapterSelect').addEventListener('focus', function() {
        this.style.outline = '3px solid orange'; // Example direct style if CSS :focus isn't enough
    });
    document.getElementById('chapterSelect').addEventListener('blur', function() {
        this.style.outline = ''; // Remove direct style
    });
    document.getElementById('verseSelect').addEventListener('focus', function() {
        this.style.outline = '3px solid orange';
    });
    document.getElementById('verseSelect').addEventListener('blur', function() {
        this.style.outline = '';
    });
</script>

</body>
</html>
